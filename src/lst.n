// ---------------- DEFINITIONS ----------------

//method selection (uncomment to include)
//#define LST__UNSAFE_ACCESS_ALLOWED

//safe memory access: comment for more performance
#define LST__HEAP_SAFE

//data structure: chk
struct LST_CHK {
	ref             dat;
	struct LST_CHK* nxt;
};
typedef struct LST_CHK lst_chk;

//data structure: main
typedef struct {
	GUulng   len;
	GUulng   itmSz;
	lst_chk* head;
} lst;






/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ LISTS ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                                 Lists by I.A.

        These lst objects are "single linked lists" with reference to their NEXT
    neighbor. Only one sens of going through the list is possible and the only
    access to data is by using the main instance "head" which refers to the 1st
    element of the list.



    PROS & CONS:

    Advantages among other common structures:
        - No maximum length
        - Does not require big allocation blocks => optimal memory re-use
        - Items can be added & removed at any index
        - Can be initialized empty
    Disadvantages among other common structures:
        - Quickly spread memory usage among different places (locality issues)
        - Uses more memory to store elements (dynamic chain chunks to be stored)
        - Operates allocations at runtime when adding/removing elements.
        - Can only be allocated on heap



    A WORD ON MEMORY MANAGEMENT WITH THIS COMMON STRUCTURE:

        This program adds a bunch of functions to work with lst objects containing
    references of a specified size in heap. Every data is stored in heap and user
    never has visibility over internal allocations & memory blocks.

        Every interaction on a dynamic amount of memory involves copy from an
    existing heap location to another. This way, user loose responsability of the
    data engaged in any of these operations.

    The only calls involving memory changes at user level are new/free() then.



    Contact: https://github.com/iasebsil83

    Let's Code !                                  By I.A..
******************************************************************************************

    LICENSE:

    stark-os/dev/core/lst
    Copyright (C) 2025 Sebastien SILVANO

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library.

    If not, see <https://www.gnu.org/licenses/>.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */






// ---------------- BASICS ----------------

//existence
lst* lst__new(GUulng itmSz){
	if(itmSz == 0){ return null; }
	lst* res   = heap__new(sizeof(lst));
	res->len   = 0;
	res->itmSz = itmSz;
	res->head  = null;
	return res;
}

void lst__free(lst* sbj){
	lst__empty(sbj);
	heap__free(sbj);
}



//unsafe indexing
static lst_chk* lst__getChk(lst* sbj, GUulng idx){
	lst_chk* cur = sbj->head;
	for(GUulng i=0; i < idx; i++){ cur = (ref)(cur->nxt); }
	return cur;
}

#ifndef LST__UNSAFE_ACCESS_ALLOWED
static
#endif
void lst__unsafe_get(lst* sbj, GUulng idx, iref dst){
	iref ir = {
		.base   = lst__getChk(sbj, idx)->dat, //    Inside lst,     chks have no offset with allocated adr
		.offset = 0                      //and inside lst_chk, dats have no offset with allocated adr neither
	};
	#ifdef LST__HEAP_SAFE
	heap__safe_w(ir, dst, sbj->itmSz); //however, we don't know about usr dst (can be anything)
	#else
	heap__unsafe_w(ir, dst, sbj->itmSz);
	#endif
}

#ifndef LST__UNSAFE_ACCESS_ALLOWED
static
#endif
void lst__unsafe_set(lst* sbj, GUulng idx, iref src){
	iref ir = {
		.base   = lst__getChk(sbj, idx)->dat, //    Inside lst,     chks have no offset with allocated adr
		.offset = 0                           //and inside lst_chk, dats have no offset with allocated adr neither
	};
	#ifdef LST__HEAP_SAFE
	heap__safe_w(src, ir, sbj->itmSz); //however, we don't know about usr src
	#else
	heap__unsafe_w(src, ir, sbj->itmSz);
	#endif
}



//safe indexing
void lst__safe_get(lst* sbj, GUulng idx, iref dst){
	if(idx >= sbj->len){ LLE__OOB return; }
	LLE__SCC
	lst__unsafe_get(sbj, idx, dst);
}

void lst__safe_set(lst* sbj, GUulng idx, iref src){
	if(idx >= sbj->len){ LLE__OOB return; }
	LLE__SCC
	lst__unsafe_set(sbj, idx, src);
}



//rm - pop - empty
void lst__rm(lst* sbj, GUulng idx){
	if(idx >= sbj->len){ LLE__OOB return; }
	LLE__SCC
	lst_chk* chk = lst__getChk(sbj, idx);

	//case 1: not the 1st chk => short-circuit using prev chk
	if(idx){ lst__getChk(sbj, idx-1)->nxt = chk->nxt; }

	//case 2: 1st chk => attach new head directly
	else{ sbj->head = chk->nxt; }

	//free allocated dat + chk
	sbj->len--;
	heap__free(chk->dat);
	heap__free(chk);
}

void lst__pop(lst* sbj, GUulng idx, iref dst){
	lst__safe_get(sbj, idx, dst);
	lst__rm(sbj, idx);
}

void lst__empty(lst* sbj){
	for(GUulng i=0; i < sbj->len; i++){ lst__rm(sbj, 0); } //rm 1st elm, "len" times
}



//last
boo  lst__isEmpty(lst* sbj          ){ return sbj->len == 0; }
void lst__last(   lst* sbj, iref dst){ lst__safe_get(sbj, sbj->len-1, dst); }
void lst__rmLast( lst* sbj          ){ lst__rm(      sbj, sbj->len-1     ); }
void lst__popLast(lst* sbj, iref dst){ lst__pop(     sbj, sbj->len-1, dst); }



//push
void lst__push(lst* sbj, iref src){

	//allocate new chk
	lst_chk* newChk = heap__new(sizeof(lst_chk));
	newChk->nxt     = null;                       // <---- in this implementation, this is facultative

	//allocate & set dat in chk
	newChk->dat = heap__new(sbj->itmSz);
	iref ir = {
		.base   = newChk->dat,
		.offset = 0
	};
	#ifdef LST__HEAP_SAFE //direct write (tiny optimization)
	heap__safe_w(src, ir, sbj->itmSz);
	#else
	heap__unsafe_w(src, ir, sbj->itmSz);
	#endif

	//attach to lst: empty => to head
	if(lst__isEmpty(sbj)){ sbj->head = newChk; }

	//attach to lst: not-empty => to last
	else{ lst__getChk(sbj, sbj->len-1)->nxt = newChk; }
}



//actions as a whole
void lst__overwrite(lst* sbj, iref src){
	for(GUulng i=0; i < sbj->len; i++){ lst__unsafe_set(sbj, i, src); }
}



//actions between lsts
lst* lst__copy(lst* src){
	lst* dst = lst__new(src->itmSz);
	iref itm = {
		.base   = heap__new(src->itmSz),
		.offset = 0
	};
	for(GUulng i=0; i < src->len; i++){
		lst__unsafe_get(src, i, itm);
		lst__push(dst, itm);
	}
	heap__free(itm.base);
	return dst;
}
