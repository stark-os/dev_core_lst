// ---------------- DEFINITIONS ----------------

//method selection (uncomment to include)
//#define LST__UNSAFE_ACCESS_ALLOWED

//safe memory access: comment for more performance
#define LST__HEAP_SAFE

//data structure: chk
struct LST_CHK {
	ref             dat;
	struct LST_CHK* nxt;
};
typedef struct LST_CHK lst_chk;

//data structure: main
typedef struct {
	GUumax   len;
	GUumax   itmSz;
	lst_chk* head;
} lst;
typedef lst* GUlst;






/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ LISTS ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                                 Lists by I.A.

        These lst objects are "single linked lists" with reference to their NEXT
    neighbor. Only one sens of going through the list is possible and the only
    access to data is by using the main instance "head" which refers to the 1st
    element of the list.



    PROS & CONS:

    Advantages among other common structures:
        - No maximum length
        - Does not require big allocation blocks => optimal memory re-use
        - Items can be added & removed at any index
        - Can be initialized empty
    Disadvantages among other common structures:
        - Quickly spread memory usage among different places (locality issues)
        - Uses more memory to store elements (dynamic chain chunks to be stored)
        - Operates allocations at runtime when adding/removing elements.
        - Can only be allocated on heap



    A WORD ON MEMORY MANAGEMENT WITH THIS COMMON STRUCTURE:

        This program adds a bunch of functions to work with lst objects containing
    references of a specified size in heap. Every data is stored in heap and user
    never has visibility over internal allocations & memory blocks.

        Every interaction on a dynamic amount of memory involves copy from an
    existing heap location to another. This way, user loose responsability of the
    data engaged in any of these operations.

    The only calls involving memory changes at user level are new/free() then.



    Contact: https://github.com/iasebsil83

    Let's Code !                                  By I.A..
******************************************************************************************

    LICENSE:

    stark-os/dev/core/lst
    Copyright (C) 2025 Sebastien SILVANO

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library.

    If not, see <https://www.gnu.org/licenses/>.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */






// ---------------- BASICS ----------------

//existence
GUlst lst__new(GUumax itmSz){
	if(itmSz == 0){ return GEnull; }
	GUlst res  = heap__new(sizeof(lst));
	res->len   = 0;
	res->itmSz = itmSz;
	res->head  = GEnull;
	return res;
}

void lst__free(GUlst sbj){
	lst__empty(sbj);
	heap__free(sbj);
}



//unsafe indexing
static lst_chk* lst__getChk(GUlst sbj, GUumax idx){
	lst_chk* cur = sbj->head;
	for(GUumax i=0; i < idx; i++){ cur = (ref)(cur->nxt); }
	return cur;
}

#ifndef LST__UNSAFE_ACCESS_ALLOWED
static
#endif
void GTGUlst_Funsafe__get(GUlst sbj, GUumax idx, iref dst){
	iref ir = {
		.base   = lst__getChk(sbj, idx)->dat, //    Inside lst,     chks have no offset with allocated adr
		.offset = 0                           //and inside lst_chk, dats have no offset with allocated adr neither
	};
	#ifdef LST__HEAP_SAFE
	heap__safe_w(ir, dst, sbj->itmSz); //however, we don't know about usr dst (can be anything)
	#else
	heap__unsafe_w(ir, dst, sbj->itmSz);
	#endif
}

#ifndef LST__UNSAFE_ACCESS_ALLOWED
static
#endif
void GTGUlst_Funsafe__set(GUlst sbj, GUumax idx, iref src){
	iref ir = {
		.base   = lst__getChk(sbj, idx)->dat, //    Inside lst,     chks have no offset with allocated adr
		.offset = 0                           //and inside lst_chk, dats have no offset with allocated adr neither
	};
	#ifdef LST__HEAP_SAFE
	heap__safe_w(src, ir, sbj->itmSz); //however, we don't know about usr src
	#else
	heap__unsafe_w(src, ir, sbj->itmSz);
	#endif
}



//safe indexing
void GTGUlst_Fsafe__get(GUlst sbj, GUumax idx, iref dst){
	if(idx >= sbj->len){ LLE__OOB return; }
	LLE__SCC
	GTGUlst_Funsafe__get(sbj, idx, dst);
}

void GTGUlst_Fsafe__set(GUlst sbj, GUumax idx, iref src){
	if(idx >= sbj->len){ LLE__OOB return; }
	LLE__SCC
	GTGUlst_Funsafe__set(sbj, idx, src);
}



//rm - pop - empty
void GTGUlst_Frm(GUlst sbj, GUumax idx){
	if(idx >= sbj->len){ LLE__OOB return; }
	LLE__SCC
	lst_chk* chk = lst__getChk(sbj, idx);

	//case 1: not the 1st chk => short-circuit using prev chk
	if(idx){ lst__getChk(sbj, idx-1)->nxt = chk->nxt; }

	//case 2: 1st chk => attach new head directly
	else{ sbj->head = chk->nxt; }

	//free allocated dat + chk
	sbj->len--;
	heap__free(chk->dat);
	heap__free(chk);
}

void GTGUlst_Fpop(GUlst sbj, GUumax idx, iref dst){
	GTGUlst_Fsafe__get(sbj, idx, dst);
	GTGUlst_Frm(sbj, idx);
}

void GTGUlst_Fempty(GUlst sbj){
	for(GUumax i=0; i < sbj->len; i++){ GTGUlst_Frm(sbj, 0); } //rm 1st elm, "len" times
}



//last
GUboo GTGUlst_FisEmpty(GUlst sbj          ){ return sbj->len == 0; }
void  GTGUlst_Flast(   GUlst sbj, iref dst){ GTGUlst_Fsafe__get(sbj, sbj->len-1, dst); }
void  GTGUlst_FrmLast( GUlst sbj          ){ GTGUlst_Frm(      sbj, sbj->len-1     ); }
void  GTGUlst_FpopLast(GUlst sbj, iref dst){ GTGUlst_Fpop(     sbj, sbj->len-1, dst); }



//push
void GTGUlst_Fpush(GUlst sbj, iref src){

	//allocate new chk
	lst_chk* newChk = heap__new(sizeof(lst_chk));
	newChk->nxt     = GEnull;                     // <---- in this implementation, this is facultative

	//allocate & set dat in chk
	newChk->dat = heap__new(sbj->itmSz);
	iref ir = {
		.base   = newChk->dat,
		.offset = 0
	};
	#ifdef LST__HEAP_SAFE //direct write (tiny optimization)
	heap__safe_w(src, ir, sbj->itmSz);
	#else
	heap__unsafe_w(src, ir, sbj->itmSz);
	#endif

	//attach to lst: empty => to head
	if(GTGUlst_FisEmpty(sbj)){ sbj->head = newChk; }

	//attach to lst: not-empty => to last
	else{ lst__getChk(sbj, sbj->len-1)->nxt = newChk; }
}



//actions as a whole
void GTGUlst_Foverwrite(GUlst sbj, iref src){
	for(GUumax i=0; i < sbj->len; i++){ GTGUlst_Funsafe__set(sbj, i, src); }
}



//actions between lsts
void GTGUlst_Fcopy(GUlst src, GUlst dst){
	if(src->itmSz != dst->itmSz){  LLE__FAI return; }
	LLE__SCC

	//clear dst lst to add src content instead
	GTGUlst_Fempty(dst);
	iref itm = {
		.base   = heap__new(src->itmSz),
		.offset = 0
	};
	for(GUumax i=0; i < src->len; i++){
		GTGUlst_Funsafe__get(src, i, itm);
		GTGUlst_Fpush(dst, itm);
	}
	heap__free(itm.base);
}
