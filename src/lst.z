// ---------------- DEFINITIONS ----------------

//data structure: chk
prv typ lst_chk {
	ref          dat,
	ref[lst_chk] nxt
}

//data structure: main
pub typ lst[1] {
	smax         len,
	smax         itmSz,
	ref[lst_chk] head
}






/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ LISTS ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                                 Lists by I.A.

        These lst objects are "single linked lists" with reference to their NEXT
    neighbor. Only one sens of going through the list is possible and the only
    access to data is by using the main instance "head" which refers to the 1st
    element of the list.



    PROS & CONS:

    Advantages among other common structures:
        - No maximum length
        - Does not require big allocation blocks => optimal memory re-use
        - Items can be added & removed at any index
        - Can be initialized empty
    Disadvantages among other common structures:
        - Quickly spread memory usage among different places (locality issues)
        - Uses more memory to store elements (dynamic chain chunks to be stored)
        - Operates allocations at runtime when adding/removing elements.
        - Can only be allocated on heap



    A WORD ON MEMORY MANAGEMENT WITH THIS COMMON STRUCTURE:

        This program adds a bunch of functions to work with lst objects containing
    references of a specified size in heap. Every data is stored in heap and user
    never has visibility over internal allocations & memory blocks.

        Every interaction on a dynamic amount of memory involves copy from a
    reserved stack location to an existing heap chunk dedicated. User looses the
    responsability of carrying dead or alive references.



    Contact: https://github.com/iasebsil83

    Let's Code !                                  By I.A..
******************************************************************************************

    LICENSE:

    stark-os/stk/zcore/lst
    Copyright (C) 2025 Sebastien SILVANO

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library.

    If not, see <https://www.gnu.org/licenses/>.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */






// ---------------- BASICS ----------------

//existence
pub fct lst.init(smax itmSz, smax len) {
	sbj.len   = 0
	sbj.itmSz = itmSz
	sbj.head  = null
}

pub fct lst.free() { sbj.empty() }

prv lst_chk lst_chk_null = lst { 0, 0, null }



//unsafe indexing
prv fct ~(ref[lst_chk] r) lst_chk {
	lst_chk l
	w(@l, r, #lst_chk)
	ret l
}

prv fct lst.getChk(smax idx) lst_chk {
	lst_chk curChk

	//null head
	if sbj.head == null { ret lst_chk_null }

	//non-null head (1st chk)
	ref[lst_chk] curChk_ref = sbj.head
	w(@curChk, curChk_ref, #lst_chk)

	//nxt chk as long as needed
	for i on idx {
		curChk_ref = curChk.nxt
		w(@curChk, curChk_ref, #lst_chk)
	}
	ret curChk
}

#CFG  LST__UNSAFE_ACCESS { pub \}
#!CFG LST__UNSAFE_ACCESS { prv \}
fct lst[dcn].unsafe_get(smax idx) dcn0 {
	dcn0 res
	#CFG  LST__HEAP_SAFE { ^Heap.safe_w(  sbj.getChk(idx).dat, 0, @res, 0, sbj.itmSz) }
	#!CFG LST__HEAP_SAFE { ^Heap.unsafe_w(sbj.getChk(idx).dat, 0, @res, 0, sbj.itmSz) }
	ret res
}

#CFG  LST__UNSAFE_ACCESS { pub \}
#!CFG LST__UNSAFE_ACCESS { prv \}
fct lst[dcn].unsafe_set(smax idx, dcn0 elm) {
	#CFG  LST__HEAP_SAFE { ^Heap.safe_w(  @elm, 0, sbj.getChk(idx).dat, 0, sbj.itmSz) }
	#!CFG LST__HEAP_SAFE { ^Heap.unsafe_w(@elm, 0, sbj.getChk(idx).dat, 0, sbj.itmSz) }
}



//safe indexing
pub fct lst[dcn].safe_get(smax idx) dcn0 {
	if idx >= sbj.len { #{lle_oob} ret null }
	#{lle_scc}
	ret sbj.unsafe_get(idx)
}

pub fct lst[dcn].safe_set(smax idx, dcn0 elm) {
	if idx >= sbj.len { #{lle_oob} ret }
	#{lle_scc}
	sbj.unsafe_set(idx, elm)
}



//rm - pop - empty
pub fct lst.rm(smax idx){
	if idx >= sbj.len { #{lle_oob} ret }
	#{lle_scc}
	lst_chk chk = sbj.getChk(idx)

	//case 1: not the 1st chk => short-circuit using prev chk
	if idx { sbj.getChk(idx-1).nxt = chk.nxt }

	//case 2: 1st chk => attach new head directly
	els { sbj.head = chk.nxt }

	//free allocated dat + chk
	//sbj.len -= 1 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
	sbj.len = sbj.len - 1
	^Heap.free(chk.dat)
	^Heap.free(@chk)
}

pub fct lst[dcn].pop(smax idx) dcn0 {
	last = sbj.safe_get(idx)
	sbj.rm(idx)
	ret last
}

pub fct lst.empty(){
	for i in sbj { sbj.rm(0) } //rm 1st elm, "len" times
}



//last
pub fct lst.isEmpty() bol {
	ret sbj.len == 0
}
pub fct lst[dcn].last() {
	ret sbj.safe_get(sbj.len-1)
}
pub fct lst.rmLast() {
	sbj.rm(sbj.len-1)
}
pub fct lst[dcn].popLast() dcn0 {
	ret sbj.pop(sbj.len-1)
}



//push
pub fct lst[dcn].push(dcn0 elm) {

	//allocate dat inside chk
	newChk_inStack = lst_chk { ^Heap.new(sbj.itmSz), null } // <---- in this implementation, "nxt=null" is facultative

	//set dat inside chk
	#CFG  LST__HEAP_SAFE { ^Heap.safe_w(  @elm, 0, newChk_inStack.dat, 0, sbj.itmSz) } //direct write (tiny optimization)
	#!CFG LST__HEAP_SAFE { ^Heap.unsafe_w(@elm, 0, newChk_inStack.dat, 0, sbj.itmSz) }

	//allocate new chk in heap
	ref[lst_chk] newChk_inHeap = ^Heap.new(#lst_chk)

	//attach to lst: empty => to head
	if sbj.isEmpty() { sbj.head = @newChk_inHeap }

	//attach to lst: not-empty => to last
	els{ sbj.getChk(sbj.len-1).nxt = @newChk_inHeap }

	//move from stack into heap allocated
	w(@newChk_inStack, newChk_inHeap, #lst_chk)
}



//actions as a whole
pub fct lst[dcn].overwrite(dcn0 elm){
	for i in sbj { sbj.unsafe_set(i, elm) }
}



//actions between lsts
pub fct lst[dcn].copy(lst[dcn0] dst) {
	if sbj.itmSz != dst.itmSz { #{lle_fai} ret }
	#{lle_scc}

	//clear dst lst to add src content instead
	dst.empty()
	for i in sbj { dst.push(sbj.unsafe_get(i)) }
}
